@page
@model EditorModel
@{
    ViewData["Title"] = "LaTeX Editor";
}

@section Styles {
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/idea.min.css" />
    <style>
        /* Custom header with dark background */
        .editor-header {
            background-color: #2c3e50;
            color: white;
            padding: 1rem;
            margin-left: -15px;
            margin-right: -15px;
            margin-top: -16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Override container for full width */
        .editor-container-fluid {
            width: 100%;
            padding-right: 0;
            padding-left: 0;
            margin-right: 0;
            margin-left: 0;
        }

        /* Make editor take more space */
        #latex-editor {
            width: 100%;
            min-height: 300px;
            height: 100%;
            resize: none;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 0;
        }

        /* Set fixed heights for content areas */
        .content-area {
            height: calc(100vh - 350px);
            min-height: 300px;
            overflow: auto;
        }

        /* Section headers */
        .section-header {
            background-color: #f8f9fa;
            padding: 0.5rem;
            font-weight: bold;
            border-bottom: 1px solid #dee2e6;
        }

        /* Error items */
        .error-high {
            border-left: 4px solid #dc3545;
            background-color: #f8d7da;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .error-medium {
            border-left: 4px solid #ffc107;
            background-color: #fff3cd;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }

        /* Status bar */
        .status-bar {
            background-color: #f8f9fa;
            padding: 0.5rem;
            border-top: 1px solid #dee2e6;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        /* CodeMirror custom styles */
        .CodeMirror {
            height: 100%;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border: 1px solid #ddd;
        }

        /* Error highlighting */
        .latex-error-high {
            background-color: rgba(254, 202, 202, 0.5);
            text-decoration: wavy underline #ef4444;
            text-decoration-thickness: 2px;
        }
            
        .latex-error-medium {
            background-color: rgba(254, 240, 138, 0.5);
            text-decoration: wavy underline #eab308;
            text-decoration-thickness: 2px;
        }

        /* Tooltip */
        .CodeMirror-tooltip {
            position: absolute;
            background-color: #2d3748;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Quality Report styles */
        .quality-report {
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
        }

        .quality-score {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .quality-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 10px;
        }

        .quality-success {
            background-color: #28a745;
            color: white;
        }

        .quality-warning {
            background-color: #dc3545;
            color: white;
        }

        .quality-issues {
            margin-top: 10px;
            padding-left: 20px;
        }

        .quality-issue {
            color: #dc3545;
            margin-bottom: 5px;
        }
        
        /* Add styling for the active button state */
        .btn-group .btn.active {
            background-color: #0d6efd;
            color: white;
        }
    </style>
}

<!-- Editor Header - Full Width -->
<div class="editor-header">
    <h1>LaTeX Editor</h1>
    <div>
        @* <button id="test-error-btn" class="btn btn-info me-2">Test Error Detection</button> *@
        <button id="download-pdf-btn" class="btn btn-primary" disabled>Download PDF</button>
    </div>
</div>

<!-- Toolbar -->
<div class="bg-light d-flex align-items-center p-2 border-bottom mb-2">
    <button id="compile-btn" class="btn btn-primary me-2">Compile</button>
    @* <button id="save-btn" class="btn btn-primary me-2">Save</button> *@
    <div class="btn-group me-2" role="group" aria-label="Citation Style">
        <a id="style-apa" href="/understem/load-apa-latex" class="btn btn-outline-primary">APA</a>
        <a id="style-mla" href="/understem/load-mla-latex" class="btn btn-outline-primary">MLA</a>
    </div>
    <span id="style-status" class="me-2">Style: <span id="current-style">APA</span></span>
</div>

<!-- Editor and Preview -->
<div class="row mx-0">
    <!-- LaTeX Editor Section -->
    <div class="col-md-6 px-0 border-end">
        <div class="section-header">LaTeX Editor</div>
        <div class="content-area">
            <textarea id="latex-editor" class="form-control border-0 p-2"></textarea>
        </div>
    </div>
    
    <!-- Preview Section -->
    <div class="col-md-6 px-0">
        <div class="section-header">PDF Preview</div>
        <div class="content-area p-2" id="pdf-preview">
            <p class="text-secondary">PDF preview will appear here after compilation.</p>
            <img src="/api/placeholder/600/800" alt="PDF preview placeholder" class="img-fluid" />
        </div>
    </div>
</div>

<!-- Error Panel -->
<div class="mt-3">
    <!-- Quality Report Section -->
    <div id="quality-report" class="quality-report">
        <div class="section-header">PDF Quality Report</div>
        <div class="quality-score">
            Quality Score: <span id="quality-score">-</span>%
            <span id="quality-status" class="quality-badge">Not Checked</span>
        </div>
        <div id="quality-issues" class="quality-issues">
            <div class="alert alert-info">
                Quality check results will appear here after compiling your document.
            </div>
        </div>
    </div>

    <div class="section-header">Errors and Warnings</div>
    <div id="error-list" class="p-2" style="max-height: 150px; overflow-y-auto;">
        <div class="alert alert-info">
            Start typing in the editor to see real-time error detection.
        </div>
    </div>
</div>

<!-- Status Bar -->
<div class="status-bar mt-2">
    <div id="compilation-status">Ready</div>
    <div id="document-info">Lines: 10 | Words: 50</div>
</div>

@section Scripts {
    <!-- CodeMirror for better editing experience -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/stex/stex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js"></script>
    
    <script>
        /**
         * LaTeX Editor with Real-time Error Detection
         */
        document.addEventListener('DOMContentLoaded', function() {
            // Editor elements
            const latexEditor = document.getElementById('latex-editor');
            const compileBtn = document.getElementById('compile-btn');
            const downloadPdfBtn = document.getElementById('download-pdf-btn');
            @* const testErrorBtn = document.getElementById('test-error-btn'); *@
            const styleApaBtn = document.getElementById('style-apa');
            const styleMlaBtn = document.getElementById('style-mla');
            const currentStyleSpan = document.getElementById('current-style');
            const errorList = document.getElementById('error-list');
            const compilationStatus = document.getElementById('compilation-status');
            @* const saveBtn = document.getElementById('save-btn'); *@
            
            // Function to update UI to reflect current style
            function updateStyleUI(style) {
                currentStyleSpan.textContent = style.toUpperCase();
                
                // Reset all buttons
                styleApaBtn.classList.remove('active');
                styleMlaBtn.classList.remove('active');
                
                // Highlight the current style button
                if (style.toLowerCase() === 'apa') {
                    styleApaBtn.classList.add('active');
                } else if (style.toLowerCase() === 'mla') {
                    styleMlaBtn.classList.add('active');
                }
            }
            
            async function getCitationStyle() {
                const match = document.cookie.match(new RegExp('(^| )selectedCitationStyle=([^;]+)'));
                if (match) return decodeURIComponent(match[2]);

                // Cookie not found, try to detect from initial LaTeX content
                try {
                    const content = await fetch('/understem/load-latex').then(r => r.text());

                    // Detect MLA markers
                    if (content.includes("(Smith 45)") || content.includes("(Thompson 77)") || content.includes("(Brown 13)")) {
                        console.log("[AUTO-DETECT] Detected MLA style from LaTeX content.");
                        document.cookie = "selectedCitationStyle=mla; path=/";
                        return "mla";
                    }

                    // Detect APA markers
                    if (content.match(/\([A-Z][a-z]+, 20\d{2}\)/g)) {
                        console.log("[AUTO-DETECT] Detected APA style from LaTeX content.");
                        document.cookie = "selectedCitationStyle=apa; path=/";
                        return "apa";
                    }

                } catch (err) {
                    console.warn("Could not detect style from LaTeX content.", err);
                }

                // Fallback default
                document.cookie = "selectedCitationStyle=apa; path=/";
                return "apa";
            }

            // Load the saved style from cookie
            getCitationStyle().then(savedStyle => {
                updateStyleUI(savedStyle);
                console.log(`[INFO] Loaded citation style: ${savedStyle}`);
                
                // Now initialize editor after style is detected
                initializeEditor(savedStyle);
            });

            
            // Set up save button
            @* saveBtn.addEventListener('click', function() {
                let latexContent = editor ? editor.getValue() : latexEditor.value;
                
                fetch('/understem/save-latex', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latexContent: latexContent })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        compilationStatus.textContent = "Saved successfully!";
                    } else {
                        compilationStatus.textContent = "Error saving: " + data.error;
                    }
                })
                .catch(error => {
                    console.error('Error saving:', error);
                    compilationStatus.textContent = "Error: Could not save the document.";
                });
            }); *@

            function autoSaveToDatabase(content) {
                fetch('/understem/save-latex', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latexContent: content })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        console.log("[AUTO-SAVE] LaTeX saved to DB.");
                    } else {
                        console.warn("[AUTO-SAVE] Failed:", data.error);
                    }
                })
                .catch(err => {
                    console.error("[AUTO-SAVE] Error:", err);
                });
            } 

            // Error detection state
            let currentErrors = [];
            let errorMarkers = [];
            let typingTimer;
            const doneTypingInterval = 100; // Wait for 1 second after typing stops
            
            // CodeMirror editor setup
            let editor;
            
            // Initialize the editor 
            function initializeEditor(styleToLoad) {
                console.log("Initializing editor...");
                
                // Try to use CodeMirror if available
                if (window.CodeMirror) {
                    console.log("Using CodeMirror editor");
                    
                    // Initialize CodeMirror
                    editor = CodeMirror.fromTextArea(latexEditor, {
                        mode: "stex",
                        lineNumbers: true,
                        theme: "default",
                        indentUnit: 4,
                        matchBrackets: true,
                        lineWrapping: true
                    });

                    // Restore from localStorage if available and editor is empty
                    const unsaved = localStorage.getItem("unsavedLatex");
                    if (unsaved && !editor.getValue().trim()) {
                        editor.setValue(unsaved);
                        console.log("[RECOVERY] Unsaved content restored from localStorage.");
                    }

                    // Watch for changes and auto-save to both localStorage + MongoDB
                    editor.on('change', function() {
                        const currentContent = editor.getValue();

                        // Local recovery save
                        localStorage.setItem("unsavedLatex", currentContent);

                        // Auto-save to DB
                        clearTimeout(typingTimer);
                        typingTimer = setTimeout(() => {
                            autoSaveToDatabase(currentContent);
                            console.log("[AUTO-SAVE] Saved to DB and localStorage.");
                        }, doneTypingInterval);
                    });

                    
                    // Set up event listener for changes
                    editor.on('change', function() {
                    const currentContent = editor.getValue();
                    autoSaveToDatabase(currentContent); // Save on every change
                    clearTimeout(typingTimer);
                    typingTimer = setTimeout(() => {
                        detectErrors(); // keep detection debounced
                    }, doneTypingInterval);
                });

                } else {
                    console.log("Using plain textarea editor");
                    
                    // Set up the basic editor
                    latexEditor.addEventListener('input', function() {
                        console.log("Textarea content changed");
                        // Clear the timeout if it's already set
                        clearTimeout(typingTimer);
                        
                        // Set a new timeout for error detection
                        typingTimer = setTimeout(detectErrors, doneTypingInterval);
                    });
                }
                
                // Load LaTeX content using savedStyle during initialization
                fetch(`/understem/load-latex?style=${styleToLoad}`)
                    .then(response => response.text())
                    .then(content => {
                        console.log(`Loaded LaTeX content from server using style: ${styleToLoad}`);
                        if (content && !content.startsWith("Error:")) {
                            if (editor) {
                                editor.setValue(content);
                            } else {
                                latexEditor.value = content;
                            }
                            detectErrors();
                        } else {
                            console.warn("No valid LaTeX content loaded:", content);
                        }
                    })
                    .catch(error => {
                        console.error("Error loading LaTeX content:", error);
                    });
            }
            
            /**
             * Detects errors in the current LaTeX content
             */
            function detectErrors() {
                console.log("[DEBUG] Detecting errors...");

                let latexContent = editor ? editor.getValue() : latexEditor.value;

                if (!latexContent.trim()) {
                    console.log("[INFO] Empty content, clearing errors.");
                    clearErrors();
                    return;
                }

                performLocalErrorChecks(latexContent);

                fetch('/error/detect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latexContent })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("[DEBUG] API response:", data);

                    if (data.success) {
                        if (data.errors.length === 0) {
                            console.log("[INFO] No errors found, keeping previous highlights.");
                            clearErrors();
                        } else {
                            console.log(`[INFO] ${data.errors.length} errors found.`);
                            currentErrors = data.errors;
                            displayErrors(currentErrors);
                            highlightErrors(currentErrors);
                        }
                    } else {
                        console.error("[ERROR] Error detection failed:", data.error);
                        compilationStatus.textContent = "Error detection failed: " + data.error;
                    }
                })
                .catch(error => {
                    console.error("[ERROR] API call failed:", error);
                    compilationStatus.textContent = "Error detection service unavailable";
                });
            }

            
            /**
             * Performs basic error checking locally in JavaScript
             */
            function performLocalErrorChecks(content) {
                console.log("Performing local error checks");
                const lines = content.split('\n');
                const localErrors = [];
                
                // Check for common issues
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // Check for unclosed document ending
                    if (line.includes("\\end{document") && !line.includes("\\end{document}")) {
                        localErrors.push({
                            line: i + 1,
                            type: "Missing } inserted",
                            message: "Missing } in \\end{document command",
                            suggestion: "Add } to close the command",
                            severity: "high",
                            canFix: true
                        });
                    }
                    
                    // Check for math symbols outside math mode
                    if (line.includes("\\alpha") && !line.includes("$\\alpha") && !line.includes("\\alpha$")) {
                        localErrors.push({
                            line: i + 1,
                            type: "Missing $ inserted",
                            message: "Symbol \\alpha requires math mode",
                            suggestion: "Enclose \\alpha with $ symbols",
                            severity: "high",
                            canFix: true
                        });
                    }
                    
                    // Check for undefined citations
                    const citeMatch = line.match(/\\cite{([^}]*)}/);
                    if (citeMatch) {
                        localErrors.push({
                            line: i + 1,
                            type: "Citation undefined",
                            message: `Citation '${citeMatch[1]}' undefined`,
                            suggestion: "Check that this citation key exists in your bibliography",
                            severity: "medium",
                            canFix: false
                        });
                    }
                }
                
                // Display local errors if any were found
                if (localErrors.length > 0) {
                    console.log("Found local errors:", localErrors);
                    displayErrors(localErrors);
                    highlightErrors(localErrors);
                }
            }
            
            /**
             * Test function to display sample errors
             */
            function testErrorDetection() {
                console.log("Running error detection test");
                const testErrors = [
                    {
                        line: 9,
                        type: "Missing $ inserted",
                        message: "Symbol \\alpha requires math mode",
                        suggestion: "Enclose the expression with $...$ or $$...$$",
                        severity: "high",
                        canFix: true
                    },
                    {
                        line: 11,
                        type: "Citation undefined",
                        message: "Citation 'unknown' undefined",
                        suggestion: "Check that this citation key exists in your bibliography",
                        severity: "medium",
                        canFix: false
                    },
                    {
                        line: 13,
                        type: "Missing } inserted",
                        message: "There is an unclosed curly brace",
                        suggestion: "Add } to close the \\end{document command",
                        severity: "high",
                        canFix: true
                    }
                ];
                
                // Display test errors
                displayErrors(testErrors);
                highlightErrors(testErrors);
                
                // Update status
                compilationStatus.textContent = "Test error detection completed";
            }
            
            /**
             * Displays errors in the error list panel
             */
            function displayErrors(errors) {
                console.log("Displaying errors:", errors);
                
                // Clear the error list
                errorList.innerHTML = '';
                
                // If no errors, show a success message
                if (!errors || errors.length === 0) {
                    errorList.innerHTML = `
                        <div class="alert alert-success">
                            No errors detected! Your LaTeX looks good.
                        </div>
                    `;
                    return;
                }
                
                // Add each error to the list
                errors.forEach((error, index) => {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = `mb-2 p-3 rounded ${error.severity === 'high' ? 'error-high' : 'error-medium'}`;
                    
                    const errorContent = `
                        <div class="d-flex justify-content-between">
                            <span>
                                <strong>Line ${error.line}:</strong> ${error.message}
                            </span>
                            ${error.canFix ? `
                                <button 
                                    class="btn btn-success btn-sm fix-error-btn" 
                                    data-error-index="${index}"
                                >
                                    Fix
                                </button>
                            ` : ''}
                        </div>
                        <div class="text-muted fst-italic small mt-1">Suggestion: ${error.suggestion}</div>
                    `;
                    
                    errorDiv.innerHTML = errorContent;
                    errorList.appendChild(errorDiv);
                });
                
                // Add event listeners to fix buttons
                document.querySelectorAll('.fix-error-btn').forEach(button => {
                    button.addEventListener('click', function() {
                        const errorIndex = parseInt(this.getAttribute('data-error-index'));
                        fixError(errorIndex);
                    });
                });
            }
            
            /**
             * Highlights errors in the editor
             */
            function highlightErrors(errors) {
                console.log("Highlighting errors in editor");

                // Clear previous highlights
                //clearErrorHighlights();

                // Skip if CodeMirror editor is not initialized
                if (!editor) {
                    console.warn("No CodeMirror editor found, skipping highlighting.");
                    return;
                }

                errors.forEach(error => {
                    try {
                        // Convert to zero-based line number
                        const line = error.line - 1;

                        // Get line content
                        const lineContent = editor.getLine(line);
                        if (!lineContent) {
                            console.warn(`Line ${line} not found in editor`);
                            return;
                        }

                        // Find the start and end positions for highlighting
                        let startCh = 0, endCh = lineContent.length;

                        if (error.type === "Missing $ inserted" && lineContent.includes("\\alpha")) {
                            startCh = lineContent.indexOf("\\alpha");
                            endCh = startCh + 6;
                        } else if (error.type.includes("Citation") && lineContent.includes("\\cite{")) {
                            startCh = lineContent.indexOf("\\cite{");
                            endCh = lineContent.indexOf("}", startCh) + 1;
                        } else if (lineContent.includes("\\end{document") && !lineContent.includes("\\end{document}")) {
                            startCh = lineContent.indexOf("\\end{document");
                            endCh = startCh + 13;
                        }

                        const from = { line: line, ch: startCh };
                        const to = { line: line, ch: endCh };

                        // Apply marker with correct class
                        const marker = editor.markText(from, to, {
                            className: error.severity === "high" ? "latex-error-high" : "latex-error-medium",
                            title: error.message
                        });

                        // Store the marker for later removal
                        errorMarkers.push(marker);
                    } catch (e) {
                        console.error("Error highlighting line:", e);
                    }
                });
            }
                        
            /**
             * Clears all error highlights
             */
            function clearErrorHighlights() {
                console.log("Clearing error highlights");
                // Clear all error markers
                errorMarkers.forEach(marker => {
                    try {
                        marker.clear();
                    } catch (e) {
                        console.error("Error clearing marker:", e);
                    }
                });
                errorMarkers = [];
            }
            
            /**
             * Clears all errors
             */
            function clearErrors() {
                console.log("Clearing all errors");
                // Clear the error list
                errorList.innerHTML = `
                    <div class="alert alert-info">
                        No errors detected yet. Start typing to see real-time error detection.
                    </div>
                `;
                
                // Clear error highlights
                clearErrorHighlights();
                
                // Reset current errors
                currentErrors = [];
            }
            
            /**
             * Fixes a specific error
             */
            function fixError(errorIndex) {
                console.log("Fixing error at index:", errorIndex);
                // Get the error
                const error = currentErrors[errorIndex];
                if (!error) {
                    console.error("Error not found at index:", errorIndex);
                    return;
                }
                
                // Get the current content
                let latexContent;
                if (editor) {
                    latexContent = editor.getValue();
                } else {
                    latexContent = latexEditor.value;
                }
                
                // Try to fix locally first for better responsiveness
                let fixedLocally = false;
                if (error.type === "Missing $ inserted" && error.message.includes("\\alpha")) {
                    // Try to fix alpha math mode error locally
                    const lines = latexContent.split('\n');
                    if (error.line <= lines.length) {
                        const line = lines[error.line - 1];
                        if (line.includes("\\alpha")) {
                            lines[error.line - 1] = line.replace("\\alpha", "$\\alpha$");
                            const fixedContent = lines.join('\n');
                            
                            if (editor) {
                                editor.setValue(fixedContent);
                            } else {
                                latexEditor.value = fixedContent;
                            }
                            
                            compilationStatus.textContent = "Fixed: Added math mode around \\alpha";
                            setTimeout(detectErrors, 500);
                            fixedLocally = true;
                        }
                    }
                } else if (error.type === "Missing } inserted" && error.message.includes("\\end{document")) {
                    // Try to fix missing bracket in \end{document} locally
                    const lines = latexContent.split('\n');
                    if (error.line <= lines.length) {
                        const line = lines[error.line - 1];
                        if (line.includes("\\end{document") && !line.includes("\\end{document}")) {
                            lines[error.line - 1] = "\\end{document}";
                            const fixedContent = lines.join('\n');
                            
                            if (editor) {
                                editor.setValue(fixedContent);
                            } else {
                                latexEditor.value = fixedContent;
                            }
                            
                            compilationStatus.textContent = "Fixed: Added missing } to \\end{document}";
                            setTimeout(detectErrors, 500);
                            fixedLocally = true;
                        }
                    }
                }
                
                // If we couldn't fix locally, try the API
                if (!fixedLocally) {
                    console.log("Attempting server-side fix for:", error);
                    
                    // Call the fix error API
                    fetch('/error/fix', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            latexContent: latexContent,
                            error: error
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log("Fix API response:", data);
                        if (data.success) {
                            // Update the editor with the fixed content
                            if (editor) {
                                editor.setValue(data.fixedContent);
                            } else {
                                latexEditor.value = data.fixedContent;
                            }
                            
                            // Re-detect errors
                            setTimeout(detectErrors, 500);
                            
                            // Show success message
                            compilationStatus.textContent = `Fixed error: ${error.message}`;
                        } else {
                            console.error('Error fixing failed:', data.error);
                            compilationStatus.textContent = `Error fixing: ${data.error}`;
                        }
                    })
                    .catch(error => {
                        console.error('Error calling fix API:', error);
                        compilationStatus.textContent = `Error: Could not fix the issue`;
                    });
                }
            }
            
            /**
             * Initializes styles for error highlighting
             */
            function initializeStyles() {
                console.log("Initializing styles");
                // Add CSS for error highlighting
                const style = document.createElement('style');
                style.textContent = `
                    .latex-error-high {
                        background-color: rgba(254, 202, 202, 0.5);
                        text-decoration: wavy underline rgba(239, 68, 68, 0.7);
                        text-decoration-thickness: 2px;
                    }
                    
                    .latex-error-medium {
                        background-color: rgba(254, 240, 138, 0.5);
                        text-decoration: wavy underline rgba(234, 179, 8, 0.7);
                        text-decoration-thickness: 2px;
                    }
                    
                    .CodeMirror-tooltip {
                        position: absolute;
                        background-color: #2d3748;
                        color: white;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        max-width: 300px;
                        z-index: 100;
                        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Set up the compile button
            compileBtn.addEventListener('click', function() {
                console.log("Compile button clicked");

                if (currentErrors.length > 0) {
                    alert("⚠️ Your document has errors! Please fix them before compiling.");
                    return;
                }

                let latexContent = editor ? editor.getValue() : latexEditor.value;
                compilationStatus.textContent = "Compiling...";

                fetch('/understem/compile-latex', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latexContent })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        compilationStatus.textContent = "Compilation successful!";
                        document.getElementById('pdf-preview').innerHTML = `
                            <iframe src="${data.pdfUrl}#${new Date().getTime()}" width="100%" height="500px" style="border: none;"></iframe>
                        `;
                        downloadPdfBtn.setAttribute("data-pdf-url", data.pdfUrl);
                        downloadPdfBtn.disabled = false;
                        
                        // Display quality check results if they're included in the response
                        if (data.qualityCheck) {
                            displayQualityResults(data.qualityCheck);
                        } else {
                            // Fall back to client-side quality check if server didn't provide results
                            setTimeout(checkPDFQuality, 1000);
                        }
                    } else {
                        compilationStatus.textContent = "Compilation failed!";
                        console.error("Compilation error:", data.error);
                        alert("Error compiling LaTeX: " + data.error);
                    }
                    setTimeout(detectErrors, 1000);
                })
                .catch(error => {
                    compilationStatus.textContent = "Compilation failed!";
                    console.error("Network or server error:", error);
                    alert("Error: Could not reach the server. Check your internet connection.");
                });
            });

            // Function to display quality results from either source
            function displayQualityResults(qualityData) {
                const qualityReport = document.getElementById('quality-report');
                const qualityScore = document.getElementById('quality-score');
                const qualityStatus = document.getElementById('quality-status');
                const qualityIssues = document.getElementById('quality-issues');

                qualityScore.textContent = qualityData.qualityScore;
                
                qualityStatus.className = 'quality-badge ' + (qualityData.isSuccessful ? 'quality-success' : 'quality-warning');
                qualityStatus.textContent = qualityData.isSuccessful ? 'Passed' : 'Issues Found';

                qualityIssues.innerHTML = '';
                if (qualityData.issues && qualityData.issues.length > 0) {
                    const issuesList = document.createElement('ul');
                    qualityData.issues.forEach(issue => {
                        const li = document.createElement('li');
                        li.className = 'quality-issue';
                        li.textContent = issue;
                        issuesList.appendChild(li);
                    });
                    qualityIssues.appendChild(issuesList);
                } else {
                    qualityIssues.innerHTML = '<div class="alert alert-success">No issues found! The PDF meets all quality standards.</div>';
                }
            }

            function checkPDFQuality() {
                fetch('@Url.Page("Editor", "CheckQuality")')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            displayQualityResults(data);
                        } else {
                            console.error('Quality check failed:', data.error);
                        }
                    })
                    .catch(error => {
                        console.error('Error checking quality:', error);
                    });
            }
            
            // Set up the download button
            downloadPdfBtn.addEventListener('click', function() {
                console.log("Download button clicked");
                const pdfUrl = this.getAttribute("data-pdf-url");
                if (pdfUrl) {
                    window.open(pdfUrl, '_blank');
                } else {
                    alert("No PDF available. Please compile the document first.");
                }
            });
            
            // Set up the test error detection button
            @* testErrorBtn.addEventListener('click', function() {
                testErrorDetection();
            }); *@
            
            // Initialize the editor
            initializeStyles();
            initializeEditor();
        });
    </script>
}